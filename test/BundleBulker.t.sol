// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console2} from "forge-std/Test.sol";
import {UserOperation,IEntryPoint} from "account-abstraction/interfaces/IEntryPoint.sol";

import {BundleBulker} from "../src/BundleBulker.sol";
import {IInflator} from "../src/IInflator.sol";
import {DaimoTransferInflator} from "../src/DaimoTransferInflator.sol";
import {DeflateInflator} from "../src/DeflateInflator.sol";

contract BundleBulkerTest is Test {
    BundleBulker public b;

    function setUp() public {
        b = new BundleBulker();
    }

    function test_AddInflator() public {
        IInflator tango = IInflator(address(0x123));
        IInflator foxtrot = IInflator(address(0x234));

        b.registerInflator(1, tango);
        assertEq(address(b.idToInflator(1)), address(tango));
        assertEq(b.inflatorToID(tango), 1);

        vm.expectRevert("Inflator ID cannot be 0");
        b.registerInflator(0, tango);
        vm.expectRevert("Inflator address cannot be 0");
        b.registerInflator(2, IInflator(address(0)));
        vm.expectRevert("Inflator already registered");
        b.registerInflator(1, foxtrot);
        vm.expectRevert("Inflator already registered");
        b.registerInflator(2, tango);

        b.registerInflator(2, foxtrot);
        assertEq(address(b.idToInflator(2)), address(foxtrot));
        assertEq(b.inflatorToID(foxtrot), 2);
    }

    function test_Inflate() public {
        DummyInflator d = new DummyInflator();
        b.registerInflator(77, d);

        bytes memory compressed = abi.encodePacked(uint32(77), address(0x999));
        (UserOperation[] memory ops, address payable beneficiary) = b.inflate(
            compressed
        );
        assertEq(beneficiary, payable(address(0x999)));
        assertEq(ops.length, 0);
    }

    function test_DaimoTransferInflator() public {
        address payable alice = payable(
            0x43370330BE39D388f6219d8241dC1f76Fb9DF268
        );
        DaimoTransferInflator t = new DaimoTransferInflator(
            address(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913),
            alice
        );
        vm.startPrank(alice);
        t.setBeneficiary(alice);
        t.setPaymaster(address(0x6f0F82fAFac7B5D8C269B02d408F094bAC6CF877));
        vm.stopPrank();

        bytes memory compressed = abi.encodePacked(
            hex"8bffa71a959af0b15c6eaa10d244d80bf23cb6a2", // sender
            hex"501c58693b65f1374631a2fca7bb7dc6", // nonce
            hex"007b44a3", // preVerificationGas
            hex"0000000f4272", // maxFeePerGas
            hex"0000000f4240", // maxPriorityFeePerGas
            hex"a1b349c566c44769888948adc061abcdb54497f7", // to
            hex"0000000f4240", // amount
            hex"0100006553c75f00", // sig version, validUntil, keySlot
            hex"ce1a2a89ec9d3cecd1e9fd65808d85702d7f8681d42ce8f0982363a362b87bd5", // sig r
            hex"498c72f497f9d27ae895c6d2c10a73e85b73d258371d2322c80ca5bfad242f5f", // sig s
            hex"415141415A5650485830567A705463726D35665A6846505F566369545433584D57484832624E7A6A6435346531774E354D32696F" // authenticatorChallenge

            // Below is OPTIONAL paymaster data. Most paymasters don't need this.
            // Even sponsoring paymasters are possible without an extra signature with tricks.
            hex"99", // paymaster sig v
            hex"7777777777777777777777777777777777777777777777777777777777777777", // paymaster sig r
            hex"8888888888888888888888888888888888888888888888888888888888888888", // paymaster sig s
            hex"00006553c999" // paymaster ticket validUntil
        );

        // Length paymaster ticket sig: 273 bytes
        // LENGTH WITH CORRECTLY OPTIMIZED PAYMASTER: 202 bytes
        assertEq(compressed.length, 273);

        (UserOperation[] memory ops, address payable beneficiary) = t.inflate(
            compressed
        );

        // Verify inflated 4337 bundle
        assertEq(beneficiary, alice);
        assertEq(ops.length, 1);

        // Verify the one userop in the bundle
        UserOperation memory op = ops[0];
        assertEq(
            op.sender,
            address(0x8bFfa71A959AF0b15C6eaa10d244d80BF23cb6A2)
        );
        assertEq(op.nonce, 0x501c58693b65f1374631a2fca7bb7dc60000000000000000);
        assertEq(op.initCode, "");
        assertEq(op.callData, 
            hex"34fcd5be" // executeBatch
            hex"0000000000000000000000000000000000000000000000000000000000000020"
            hex"0000000000000000000000000000000000000000000000000000000000000001"
            hex"0000000000000000000000000000000000000000000000000000000000000020"
            hex"000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda02913"
            hex"0000000000000000000000000000000000000000000000000000000000000000"
            hex"0000000000000000000000000000000000000000000000000000000000000060"
            hex"0000000000000000000000000000000000000000000000000000000000000044"
            hex"a9059cbb" // transfer
            hex"000000000000000000000000a1b349c566c44769888948adc061abcdb54497f7"
            hex"00000000000000000000000000000000000000000000000000000000000f4240"
            hex"00000000000000000000000000000000000000000000000000000000"
        );
        assertEq(op.callGasLimit, 300000);
        assertEq(op.verificationGasLimit, 700000);
        assertEq(op.preVerificationGas, 8078499);
        assertEq(op.maxFeePerGas, 1000050);
        assertEq(op.maxPriorityFeePerGas, 1000000);
        assertEq(
            op.paymasterAndData,
            hex"6f0F82fAFac7B5D8C269B02d408F094bAC6CF877"
            hex"99"
            hex"7777777777777777777777777777777777777777777777777777777777777777"
            hex"8888888888888888888888888888888888888888888888888888888888888888"
            hex"00006553c999"
        );
        assertEq(
            op.signature,
            abi.encodePacked(
                hex"01"
                hex"00006553c75f"
                hex"00"
                hex"0000000000000000000000000000000000000000000000000000000000000020"
                hex"00000000000000000000000000000000000000000000000000000000000000c0"
                hex"0000000000000000000000000000000000000000000000000000000000000120"
                hex"0000000000000000000000000000000000000000000000000000000000000017"
                hex"0000000000000000000000000000000000000000000000000000000000000001"
                hex"ce1a2a89ec9d3cecd1e9fd65808d85702d7f8681d42ce8f0982363a362b87bd5"
                hex"498c72f497f9d27ae895c6d2c10a73e85b73d258371d2322c80ca5bfad242f5f"
                hex"0000000000000000000000000000000000000000000000000000000000000025"
                hex"0000000000000000000000000000000000000000000000000000000000000000"
                hex"0500000000000000000000000000000000000000000000000000000000000000"
                hex"000000000000000000000000000000000000000000000000000000000000005a",
                '{"type":"webauthn.get","challenge":"AQAAZVPHX0VzpTcrm5fZhFP_VciTT3XMWHH2bNzjd54e1wN5M2io"}',
                hex"000000000000"
            )
        );
    }

    function test_DeflateInflator() public {
        DeflateInflator d = new DeflateInflator();
        b.registerInflator(0x42, d);

        // Taken from a real bundle that was submitted to the network:
        // https://basescan.org/tx/0xacb32cca8ddefcf73cb16fda17ff34cf15382e4e0cfb7a96e8149011a5fe3d29
        bytes memory raw = hex'000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000008bffa71a959af0b15c6eaa10d244d80bf23cb6a20000000000000000501c58693b65f1374631a2fca7bb7dc600000000000000000000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000493e000000000000000000000000000000000000000000000000000000000000aae6000000000000000000000000000000000000000000000000000000000007b44a300000000000000000000000000000000000000000000000000000000000f427200000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014434fcd5be000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda02913000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000a1b349c566c44769888948adc061abcdb54497f700000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001499d720cd5a04c16dc5377638e3f6d609c895714f00000000000000000000000000000000000000000000000000000000000000000000000000000000000001e80100006553c75f00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000170000000000000000000000000000000000000000000000000000000000000001ce1a2a89ec9d3cecd1e9fd65808d85702d7f8681d42ce8f0982363a362b87bd5498c72f497f9d27ae895c6d2c10a73e85b73d258371d2322c80ca5bfad242f5f000000000000000000000000000000000000000000000000000000000000002500000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006f7b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a22415141415a5650485830567a705463726d35665a6846505f566369545433584d57484832624e7a6a6435346531774e354d32696f222c226f726967696e223a226461696d6f2e636f6d227d0000000000000000000000000000000000000000000000000000000000000000000000000000000000';
        UserOperation[] memory originalOps = abi.decode(abi.encodePacked(uint256(0x20), raw), (UserOperation[]));
        
        string[] memory inputs = new string[](3);
        inputs[0] = "node";
        inputs[1] = "test/deflate.js";
        inputs[2] = '000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000008bffa71a959af0b15c6eaa10d244d80bf23cb6a20000000000000000501c58693b65f1374631a2fca7bb7dc600000000000000000000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000493e000000000000000000000000000000000000000000000000000000000000aae6000000000000000000000000000000000000000000000000000000000007b44a300000000000000000000000000000000000000000000000000000000000f427200000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014434fcd5be000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000833589fcd6edb6e08f4c7c32d4f71b54bda02913000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000a1b349c566c44769888948adc061abcdb54497f700000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001499d720cd5a04c16dc5377638e3f6d609c895714f00000000000000000000000000000000000000000000000000000000000000000000000000000000000001e80100006553c75f00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000170000000000000000000000000000000000000000000000000000000000000001ce1a2a89ec9d3cecd1e9fd65808d85702d7f8681d42ce8f0982363a362b87bd5498c72f497f9d27ae895c6d2c10a73e85b73d258371d2322c80ca5bfad242f5f000000000000000000000000000000000000000000000000000000000000002500000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006f7b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a22415141415a5650485830567a705463726d35665a6846505f566369545433584d57484832624e7a6a6435346531774e354d32696f222c226f726967696e223a226461696d6f2e636f6d227d0000000000000000000000000000000000000000000000000000000000000000000000000000000000';
        bytes memory compressed = vm.ffi(inputs);
        
        (UserOperation[] memory inflatedOps, address payable beneficiary) = b.inflate(
            abi.encodePacked(uint32(0x42), uint24(raw.length), compressed)
        );

        assertEq(beneficiary, tx.origin);
        assertEq(abi.encode(inflatedOps), abi.encode(originalOps));

        // Calculate and print compression ratios
        
        bytes memory uncompressedCallData = abi.encodeWithSelector(IEntryPoint.handleOps.selector, originalOps, tx.origin);
        uint256 uncompressedCallDataLength = uncompressedCallData.length;
        uint256 uncompressedCallDataCost = calculateCalldataCost(uncompressedCallData);

        bytes memory compressedCallData = abi.encodePacked(uint32(0x42), uint24(raw.length), compressed);
        uint256 compressedCallDataLength = compressedCallData.length;
        uint256 compressedCallDataCost = calculateCalldataCost(compressedCallData);

        console2.log("Uncompressed calldata length:       ", uncompressedCallDataLength);
        console2.log("Deflate compressed calldata length: ", compressedCallDataLength);
        console2.log("Calldata length compression ratio:  ", 100 - (compressedCallDataLength * 1e2) / uncompressedCallDataLength, "%");
        console2.log("");
        console2.log("Uncompressed calldata cost:         ", uncompressedCallDataCost);
        console2.log("Deflate compressed calldata cost:   ", compressedCallDataCost);
        console2.log("Calldata cost compression ratio:    ", 100 - (compressedCallDataCost * 1e2) / uncompressedCallDataCost, "%");
    }

    function calculateCalldataCost(bytes memory callData) public pure returns (uint256 cost) {
        // 0 bytes cost 4 gas, non-0 bytes cost 16 gas
        for (uint256 i = 0; i < callData.length; i++) {
            if (callData[i] == 0) {
                cost += 4;
            } else {
                cost += 16;
            }
        }
    }



}

contract DummyInflator is IInflator {
    function inflate(bytes calldata compressed)
        external
        override
        pure
        returns (UserOperation[] memory ops, address payable beneficiary)
    {
        assert(compressed.length == 20);
        ops = new UserOperation[](0);
        beneficiary = payable(address(bytes20(compressed[0:20])));
    }
}